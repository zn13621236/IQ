package com.real.go.two;

import java.util.ArrayList;
import java.util.List;
import com.real.go.one.MakeMine8.ListNode;
import com.real.go.one.MakeMine9.TreeNode;

public class MakeMine10 {
    /*
     * Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3
Note:
Bonus points if you could solve it both recursively and iteratively.
     */
// public boolean isSymmetric(TreeNode root) {
//        
//    }
   
    /*
     * Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
     */
  
// public List<List<Integer>> levelOrder(TreeNode root) {
//        
//    }
    
    
    /*
     * Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
     */
//  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
//        
//    }  
    
    
    /*
     * Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
     */
    
//  public int maxDepth(TreeNode root) {
//        
//    } 
    
    /*
     * Given preorder and inorder traversal of a tree, construct the binary tree.
     */

// public TreeNode buildTree(int[] preorder, int[] inorder) {
//        
//    }

    
    /*
     * Given inorder and postorder traversal of a tree, construct the binary tree.
     */
    
// public TreeNode buildTree(int[] inorder, int[] postorder) {
//        
//    }
    
    
    /*
     * Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree {3,9,20,#,#,15,7},
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
     */
    
//public List<List<Integer>> levelOrderBottom(TreeNode root) {
//        
//    }
    
   /*
    * Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
    */
    
//    public TreeNode sortedArrayToBST(int[] num) {
//        
//    }
    
   
    /*
     * Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
     */
    
//   public TreeNode sortedListToBST(ListNode head) {
//        
//    }
    
  
    
    /*
     * Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
     */
    
//  public boolean isBalanced(TreeNode root) {
//        
//    }
    
    
    
}
