package tree;

import java.util.List;
import tree.MakeMine80.ListNode;
import tree.MakeMine90.TreeNode;

public class MakeMine140 {
    
    /*
     * Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?
     */
// public boolean hasCycle(ListNode head) {
//        
//    }
 
    
    /*
     * Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Follow up:
Can you solve it without using extra space?
     */
// public ListNode detectCycle(ListNode head) {
//        
//    }
  
    /*
     * Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.
     */
 public void reorderList(ListNode head) {
        
    }
 
 
 /*
  * Given a binary tree, return the preorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [1,2,3].

Note: Recursive solution is trivial, could you do it iteratively?
  */
 
// public List<Integer> preorderTraversal(TreeNode root) {
//     
// } 
 
 
 /*
  * Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},
   1
    \
     2
    /
   3
return [3,2,1].

Note: Recursive solution is trivial, could you do it iteratively?
  */
 
// public List<Integer> postorderTraversal(TreeNode root) {
//     
// }
 
 
 /*
  * Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
  */
 
 public class LRUCache {
     
     public LRUCache(int capacity) {
         
     }
     
//     public int get(int key) {
//         
//     }
     
     public void set(int key, int value) {
         
     }
 }
 
 
 
/*
 * Sort a linked list using insertion sort.
 */
 
// public ListNode insertionSortList(ListNode head) {
//     
// }

/*
 * Sort a linked list in O(n log n) time using constant space complexity.
 */
// public ListNode sortList(ListNode head) {
//     
// }


 /*
  * Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
  */
 
// public int maxPoints(Point[] points) {
//     
// }
 
 
 /*
  * Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Some examples:
  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
  */
 
// public int evalRPN(String[] tokens) {
//     
// }
 
}
