package tree;

import java.util.List;

import tree.Tree.ListNode;

public class MakeMine20 {
	/*
	 * Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
	 */
	
	 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	        return null;
	    }
	
	/*
	 * Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

"((()))", "(()())", "(())()", "()(())", "()()()"
	 */

	 public List<String> generateParenthesis(int n) {
	        return null;
	    }

/*
 * Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
 */

	  public ListNode mergeKLists(List<ListNode> lists) {
	        return null;
	    }
	 
	/*
	 * Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 
	 */
	  
	  public ListNode swapPairs(ListNode head) {
	        return null;
	    }
	  
	  
	  /*
	   * Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5
	   */
	  public ListNode reverseKGroup(ListNode head, int k) {
	        return null;
	    }  
	  
	  
	  /*
	   * Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array A = [1,1,2],

Your function should return length = 2, and A is now [1,2].
	   */
	  public int removeDuplicates(int[] A) {
	     return -1;   
	    }
	  
	  
	  /*
	   * Given an array and a value, remove all instances of that value in place and return the new length.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.
	   */
	  public int removeElement(int[] A, int elem) {
	        return -1;
	    }
	  
	  
	  /*
	   * Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
	   */
	  
	  
	  public int strStr(String haystack, String needle) {
	        return -1;
	    }
	  
	  /*
	   * Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.
	   */
	  
	  public int divide(int dividend, int divisor) {
	        return -1;
	    }
	  
	  /*
	   * You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters.

For example, given:
S: "barfoothefoobarman"
L: ["foo", "bar"]

You should return the indices: [0,9].
(order does not matter).
	   */
	  
	  public List<Integer> findSubstring(String S, List<String> L) {
	        return null;
	    }
	  
}
